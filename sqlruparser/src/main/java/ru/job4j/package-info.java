package ru.job4j;
/**
 * Парсер вакансий для сайта sql.ru
 * Для выполнения данной работы я создал БД из  нескольких таблиц
 * 1.	Таблица title хранит заголовок темы и id
 * 2.	Таблица author  хранит список авторов и id
 * 3.	 Таблица description  хранит описание вакансий и id
 * 4.	Основная таблица, datatable, осуществляет связь многие ко многим, не секрет что у одного автора
 * может быть несколько тем,  темы могут повторяться, и даже описания вакансий могут повторяться,  например автор
 * продублировал своё объявление создав объявление с новой темой а описание осталось, или просто кто-то ленивый скопипастил описание.
 * Также эта таблица хранит url которые не могут повторяться, и даты, которые я буду брать из первого поста темы.
 * В связи с этим, чтобы исключить дублирование информации такие данные как
 * автор, название и описание хранится в единственном экземпляре и организована связь.
 * После выполнения парсинга вакансий моя программа выводит статистическое сообщение:
 *
 * Количество тем всего :30936
 * Количество повторяющихся авторов :4086
 * Количество повторяющихся наименований тем :1327
 * Количество повторяющихся описаний вакансий :703
 *
 * Статистику программа собирает по основной таблице datatable  ,  производится запрос,
 * который подсчитывает количество совпадений id  в той или иной колонке
 *
 * select data.count as "Количество тем всего", aut.count as "Количество повторяющихся авторов", tit.count as "Количество повторяющихся наименований тем", descr.count as "Количество повторяющихся описаний вакансий" from
 * (select count(id) from datatable) as data
 * inner join (select count(a.id) from author as a right outer join (select dat.author_id, count(id) from datatable as dat group by dat.author_id) as res on res.author_id = a.id where res.count > 1) as aut on aut.count!=data.count
 * inner join  (select count(t.id) from title as t right outer join (select dat.title_id, count(id) from datatable as dat group by dat.title_id) as res on res.title_id = t.id where res.count > 1) as tit on tit.count != data.count
 * inner join (select count(des.id) from description as des right outer join (select dat.description_id, count(id) from datatable as dat group by dat.description_id) as res on res.description_id = des.id where res.count > 1) as descr on descr.count != data.count;
 *
 * Что наглядно показывает, на сколько хорошо проведена нормализация базы.
 * Что касается самой программы: даты берутся из первого поста темы, т.к. это и будет датой создания объявления
 * Решил скачивать и описание вакансии т.к. если мы захотим из нашей БД выгружать вакансии на наш сайт, то хорошо бы чтоб они были с описаниями.
 * Даты для цикла проверки актуальности программа берёт из основной страницы не праваливаясь в тему http://www.sql.ru/forum/job-offers
 * т.к. если мы начнём отрубать темы по датам, которые просто обновлены и были подняты вверх, у нас есть шанс наткнуться просто на старую тему которую «апнули» и
 * программа может прекратить свою работу. Но в самой базе мы храним  даты, которые мы будем брать из первого поста.
 *
 * За парсинг строки с датой полностью отвечает объект класса Month
 * Название темы тоже редактируется при получении в лямбда выражении удаляя из неё всё ненужное [new]  (1, 2,)
 *
 * Т.е. при парсинге постепенно формируется объект класса Vakancy   который далее передаётся в метод
 * public void addtoData(Vacancy vacancyElement)
 * перед добавлением я делаю запрос в таблицу авторов а есть ли автор? и если есть то я получу его id
 * и просто не буду добавлять его в таблицу авторов, а его id запихаю в основную таблицу datatable,
 * также проделаю и с темой и с описанием вакансии
 *
 * Отключен автокоммит, т.к. мы будем делать несколько запросов на добавление данных авторы, темы урл, описание а в конце метода коммит.
 *
 * Для тестирования я использовал файл app.properties
 * jdbc.driver = org.postgresql.Driver
 * jdbc.url = jdbc:postgresql://localhost:5432/vacancy
 * jdbc.username = postgres
 * jdbc.password = 444444
 * cron.time = 0/20 * * * * ?
 *
 * cron.time в тестовом случае этот параметр будет означать запуск приложения каждые 20 секунд.
 * в данной версии параметр crn.time  равен 0 0 12 * * ? что означает запуск приложения каждый день в 12 часов
 *
 *
 **/